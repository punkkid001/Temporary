실행 결과에서 TestCase1과 TestCase2의 코드를 비교하면, 
배열 크기가 커질수록 실행시간이 늘어나는 차이가 점점 커지는 것을 확인할 수 있었습니다. 

각각의 코드를 시간 복잡도로 살펴보면 TestCase1은 O(n), TestCase2는 O(n^2)d으로 
n의 크기에 따라서 TestCase2의 실행시간이 매우 큰 폭으로 늘어나는 것을 알 수 있습니다. 

이는 실행결과에서도 확인할 수 있는데, n=10000일때 181ms이던 실행시간이 10배 더 많은 
n=100000일 때에는 3988ms로 매우 큰 폭으로 실행시간이 늘어난 것을 확인할 수 있습니다. 


반면에 O(n)인 TestCase1에서는 n=100000에서도 0ms이던 실행시간이 (ns로 보면 차이가 있을 수 있습니다.) 
10배 더 많은 n=1000000에 들어서야 15ms라는 실행시간으로 TestCase2에 비하여 매우 적은 폭으로 실행시간이 
늘어나는 것을 확인할 수 있었습니다. 

TestCase2가 TestCase1보다 실행시간이 느린 이유는 조금 더 많은 Assignment가 있었고, 중첩 for문이 존재하였기 때문이라고 봅니다.
n과 n^2의 그래프를 비교하더라도, n^2에서 기울기가 급격하게 변화하기 때문에 O(n^2)의 실행시간을 가지는 알고리즘은 상당히 비효율적이라고 볼 수 있습니다.